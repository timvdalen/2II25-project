We will use the SPARQL endpoint of DBpedia as our main data source.
To find related movies for a certain movie \textbf{a}, we first query DBpedia to find \textbf{a}.
We will them use predicates defined by the \textit{dbpedia-owl} namespace to find movies that are related to \textbf{a}.
This namespace contains predicates such as \texttt{starring}, \texttt{director}, \texttt{editor} and \texttt{country}.
We will assign edge-weights to these predicates, so that an edge of type \texttt{starring}
is more important than an edge of type \texttt{country}.

Here, we define ``being related'' as sharing a certain value for a property.
So, for two movies \textbf{a} and \textbf{b}, $\textbf{a} \neq \textbf{b}$,

\begin{lstlisting}
?a rdf:type dbpedia-owl:Film,
?b rdf:type dbpedia-owl:Film,
?a dbpedia-owl:starring ?actor
?b dbpedia-owl:starring ?actor
\end{lstlisting}

means that \textbf{a} and \textbf{b} are related because they share an actor in a major role.

This way, we will directly link movie nodes that are in some way connected to each other in DBpedia.
Because of this destillation process, the resulting graph will be much more sparse
and we will easily be able to see the information we are interested in.
